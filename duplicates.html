<!DOCTYPE html>
<html>
<head>
<title>Speedrun Duplicate Finder</title>
<style>
body { font-family: sans-serif; }
#results { margin-top: 20px; }
.duplicate-group { margin-bottom: 10px; border: 1px solid #ccc; padding: 10px; }
</style>
</head>
<body>

<h1>Speedrun Duplicate Finder</h1>

<label for="game-abbr">Game Abbreviation:</label>
<input type="text" id="game-abbr" placeholder="e.g., smb1"><br><br>

<button onclick="findDuplicates()">Find Duplicates</button>

<div id="results"></div>

<script>
async function getGameId(abbreviation) {
    const response = await fetch(`https://www.speedrun.com/api/v1/games?abbreviation=${abbreviation}`);
    if (!response.ok) {
        throw new Error(`Error fetching game ID (HTTP ${response.status} ${response.statusText})`);
    }
    const data = await response.json();
    if (data.data.length === 0) {
        throw new Error("No game found with that abbreviation.");
    }
    return data.data[0].id;
}

async function getRuns(gameId) {
    let url = `https://www.speedrun.com/api/v1/runs?game=${gameId}&max=200&status=verified`;

    return new Promise(async (resolve, reject) => {
        try {
            let allRuns = [];
            let offset = 0;
            let hasMore = true;

            while (hasMore) {
                const response = await fetch(url + `&offset=${offset}`);
                if (!response.ok) {
                  return reject(`Error fetching runs (HTTP ${response.status} ${response.statusText})`);
                }
                const data = await response.json();
                allRuns = allRuns.concat(data.data);
                hasMore = data.pagination.size + offset < data.pagination.offset + data.pagination.max;
                offset = data.pagination.offset + data.pagination.max;
            }
            resolve(allRuns);
        } catch (error) {
            reject(error); 
        }
    });
}

function compareVideos(run1, run2) {
    if (!run1.videos || !run2.videos || !run1.videos.links || !run2.videos.links) {
        return false;
    }

    const normalizeLink = (link) => {
        let uri = link.uri.toLowerCase();
        // Handle youtu.be short links
        if (uri.includes("youtu.be/")) {
            uri = "https://www.youtube.com/watch?v=" + uri.split("youtu.be/")[1];
        }
        // Remove any trailing slashes or query parameters
        uri = uri.split("?")[0].replace(/\/$/, ""); 
        return uri;
    };

    const links1 = run1.videos.links.map(normalizeLink).sort();
    const links2 = run2.videos.links.map(normalizeLink).sort();

    if (links1.length !== links2.length) {
        return false;
    }

    for (let i = 0; i < links1.length; i++) {
        if (links1[i] !== links2[i]) {
            return false;
        }
    }

    return true; 
}

function findDuplicateRuns(runs) {
    const seenRuns = new Map();
    const duplicates = [];

    for (const run of runs) {
        const runKey = JSON.stringify(
            [...run.players.map(p => p.rel === 'user' ? p.id : p.name)].sort().concat([run.times.primary, run.category])
        );
        if (seenRuns.has(runKey)) {
            const existingRun = seenRuns.get(runKey);
            if (compareVideos(run, existingRun)) {
                 duplicates.push([run, existingRun]);
             }
        } else {
            seenRuns.set(runKey, run);
        }
    }
    return duplicates;
}

function formatTime(time) {
  const timeParts = time.match(/PT(\d+H)?(\d+M)?(\d+(\.\d+)?)S/);
  if (!timeParts) {
    return time; // Return original time if it doesn't match the expected format
  }

  const hours = timeParts[1] ? parseInt(timeParts[1]) : 0;
  const minutes = timeParts[2] ? parseInt(timeParts[2]) : 0;
  const seconds = parseFloat(timeParts[3]);

  let formattedTime = "";
  if (hours > 0) {
    formattedTime += `${hours}:${minutes.toString().padStart(2, '0')}:`;
  } else {
    formattedTime += `${minutes}:`;
  }
  formattedTime += `${seconds.toFixed(3).padStart(5, '0')}`;

  return formattedTime;
}

async function getUserName(userId) {
  const response = await fetch(`https://www.speedrun.com/api/v1/users/${userId}`);
  if (!response.ok) {
    throw new Error(`Error fetching user name (HTTP ${response.status} ${response.statusText})`);
  }
  const data = await response.json();
  return data.data.names.international; // Use the international name
}

async function findDuplicates() {
    const gameAbbr = document.getElementById('game-abbr').value;
    const resultsDiv = document.getElementById('results');

    resultsDiv.innerHTML = "Loading...";

    try {
        const gameId = await getGameId(gameAbbr);
        const runs = await getRuns(gameId);
        const duplicateRuns = findDuplicateRuns(runs);

        if (duplicateRuns.length > 0) {
            let output = "<h2>Duplicate Runs Found:</h2>";
            for (const [run1, run2] of duplicateRuns) {
                output += `<div class="duplicate-group">`;
                // Get player names using getUserName
                const playerNames1 = await Promise.all(run1.players.map(async p => p.rel === 'user' ? await getUserName(p.id) : p.name));
                const playerNames2 = await Promise.all(run2.players.map(async p => p.rel === 'user' ? await getUserName(p.id) : p.name));
        
                output += `<p>Run 1: <a href="${run1.weblink}" target="_blank">${run1.weblink}</a> by ${playerNames1.join(', ')} - ${formatTime(run1.times.primary)}</p>`;
                output += `<p>Run 2: <a href="${run2.weblink}" target="_blank">${run2.weblink}</a> by ${playerNames2.join(', ')} - ${formatTime(run2.times.primary)}</p>`;
                output += `<p>Category: ${run1.category.name}</p>`;
                output += `</div>`;
            }
            resultsDiv.innerHTML = output;
        } else {
            resultsDiv.innerHTML = "<p>No duplicate runs found.</p>";
        }
    } catch (error) {
        resultsDiv.innerHTML = `<p style="color: red;">Error: ${error}</p>`;
        console.error("Error:", error);
    }
}
</script>

</body>
</html>
